# tree

题目: 写一个 tree.py, 通过 python tree.py 模拟实现linux 命令行 tree 的输出



```

# tree

.

├── interview.md

└── logs

└── file1_1.log

```



●●●●●●●●●●●●●●●





# 九宫图生成器（又称洛书或河图）

题目：输入一个整数 k (k < 50), 输出一个 k*k 的九宫图。



```

5*5

17 24 01 08 15

23 05 07 14 16

04 06 13 20 22

10 12 19 21 03

11 18 25 02 09



4*4

16 02 03 13

05 11 10 08

09 07 06 12

04 14 15 01



```





●●●●●●●●●●●●●●●





# 数独生成器

题目：写一个数独生成器，接受输入一个9 * 9 矩阵M（可为空），通过填充该矩阵，输出一个数独。

```

矩阵由以下符号表示：

‘*’ 表示 数字未知。

‘1-9’ 表示已知的数字。

```







●●●●●●●●●●●●●●●





# 类的内省和装饰器

题目：写一个 类

```

class Mlog(object):

pass

```

使任意继承 Mlog的子类，在调用其属性方法的时候，会打印(stdout)出这个子类的类名，被调用的属性方法和参数值列表，开始运行时间，结束运行时间，以及函数运行的结果。





形如:

```

class Any(Mlog):

def track(..args, **kwars):

pass





a = Any()

a.track(1,2,3, a="xx")

```

输出

```

[Mlog] Any.track(1,2,3, a="xx")

[start] {start_timestamp}

[end] {end_timestamp}

[result] {result}

```





●●●●●●●●●●●●●●●





# 命令行扫雷

题目：实现扫雷游戏。



该游戏在一个10*10的棋盘中，随机分布着15个雷。

棋盘由以下符号表示：

‘#’ 表示该格子未揭开

‘ ‘ 表示该格子附近8个格子没有雷

‘1-8’ 数字表示该格子附近有多少个雷

‘*’ 表示该格子是地雷

玩家可以按 WASD 进行上下左右移动光标，按空格揭开格子。当揭开的格子是地雷时，打印‘you lose’；当揭开格子附近有地雷时，显示附近有多少个雷；

当揭开格子附近无地雷时，显示为空格并上下左右四周扩散；当揭开格子后剩余格子全是地雷时，打印 ‘you win’。
